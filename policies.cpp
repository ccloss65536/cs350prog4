#include "policies.hpp"

#include <vector>
#include <unordered_set>
#include <algorithm>

using std::vector;

static const int INVALID_PAGE = -1;

/*!
 *  \brief Calculate number of page hits when using FIFO page replacement policy.
 *
 *  Calculates the number of page cache hits generated for a given sequence of
 *  page accesses when using the FIFO page replacement policy.
 *
 *  \param workload Vector of page accesses to evaluate
 *  \param memsize Memory size, in pages
 *  \return Number of cache hits generated by using FIFO policy
 */
int PRP_FIFO(const vector<int>& workload, int memsize) {
    int hits = 0;
    vector<int> cachedPages(memsize, INVALID_PAGE);
    vector<int>::size_type cachedPagesHead = 0;

    // Loop for each page access in workload
    for (int access : workload) {
        // Check if page being accessed is in the page cache
        if (std::count(cachedPages.begin(), cachedPages.end(), access) > 0) {
            // Page cache hit
            hits++;
        } else {
            // Page cache miss
            // Replace page at head of queue with the one being accessed
            cachedPages.at(cachedPagesHead) = access;
            // Move head of queue forward by one
            cachedPagesHead = (cachedPagesHead + 1) % cachedPages.size();
        }
    }

    return hits;
}

int PRP_OPT(const vector<int>& workload, int memsize){
	std::unordered_set<int> pages_in_mem;
	int hits = 0;
	for(unsigned int i = 0; i < workload.size(); i++){
		if(pages_in_mem.count(workload[i]) > 0){
			hits++;
		} 
		else if(pages_in_mem.size() < memsize){
			pages_in_mem.insert(workload[i]);
		}
		else {
			std::unordered_set<int> replacement_canidiates = pages_in_mem;
			unsigned int j = i;
			for(;j < workload.size() && replacement_canidiates.size() > 1; j++){
				if(replacement_canidates.count(workload[j] > 0){
					replacement_canidiates.erase(workload[j]);
				}
			}
			pages_in_mem.erase( *(replacement_canidiates.begin()) );
			pages_in_mem.insert(workload[i]);
	}
	return hits; 
			
